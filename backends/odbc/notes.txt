http://developer.mimer.com/howto/howto_26.htm

Array Insert
If you want to insert more than one row in a table, then we recommend that you use the ODBC array insert feature. This reduces server round trips and yields much faster insert performance as well as reducing demands on server resources as a whole.

Suppose that you want to insert 100 rows in a table. The following code snippet shows a typical way to do this:

{
    SQLINTEGER val;
    SQLINTEGER len = 0;

    SQLPrepare(hstmt, "INSERT INTO T1 (C1) VALUES (?)", SQL_NTS);
    SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_INTEGER, SQL_C_SLONG, 0,
                     0, &val, 0, &len);

    for (val = 1; val <= 100; val++) {
        SQLExecute(hstmt);
    }
}

This code will result in 1+100 server round trips (one for the prepare).
You can reduce this to 2 server calls by using array insert as demonstrated below:

{
    int i;
    SQLINTEGER val[100];
    SQLUSMALLINT rows_processed = 0;
    SQLSetStmtAttr(hstmt, SQL_ATTR_PARAMSET_SIZE, (SQLPOINTER)100, 0);
    SQLSetStmtAttr(hstmt, SQL_ATTR_PARAMS_PROCESSED_PTR, &rows_processed, 0);
    SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_INTEGER, SQL_C_LONG, 0, 0,
     &val, 0, NULL);
    SQLPrepare(hstmt, "INSERT INTO T1 (C1) VALUES (?)", SQL_NTS);
    
    /* fill array with values */
    for (i = 0; i < 100; i++) {
        val[i] = i;
    }
    SQLExecute(hstmt);
    if (rows_processed != 100) {
        /* possible error */
    }
}

The example above uses the ODBC column-wise binding feature and
SQLSetStmtAttr(...,SQL_ATTR_PARAMSET_SIZE, ...) sets the array size of the parameter.
The statement attribute SQL_ATTR_PARAMS_PROCESSED_PTR is used to assign a deferred status variable which is filled by SQLExecute and contains the number of rows which were actually inserted.
If your application is deployed over a network with long ping times, using array insert will result in a huge improvement in speed.



    // set up uses
    SQLRETURN rc;
    rc = SQLSetStmtAttr(statement_.hstmt_, SQL_ATTR_PARAMSET_SIZE, 
                        (SQLPOINTER) vectorSize_ , 0);
    if (is_odbc_error(rc))
    {
        throw new ODBCSOCIError(SQL_HANDLE_STMT, statement_.hstmt_, 
                                "Set size of param array");
    }

    rc = SQLSetStmtAttr(statement_.hstmt_, SQL_ATTR_PARAMS_PROCESSED_PTR, 
                        (SQLPOINTER) &numProcessed_ , 0);
    if (is_odbc_error(rc))
    {
        throw new ODBCSOCIError(SQL_HANDLE_STMT, statement_.hstmt_, 
                                "Set value to hold number processed");
    }

    rc = SQLSetStmtAttr(statement_.hstmt_, SQL_ATTR_PARAM_STATUS_PTR,
                        (SQLPOINTER) statusHolders_ , 0);
    if (is_odbc_error(rc))
    {
        throw new ODBCSOCIError(SQL_HANDLE_STMT, statement_.hstmt_, 
                                "Binding to status array");
    }



////////////////////////////////////////////////////////


    static char adata[][2] = {"a","b","c","d"};


    SQLRETURN rc = SQLBindParameter(statement_.hstmt_, 1, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, 2, 0, 
                     (SQLPOINTER)adata, 2, NULL);

    std::cerr << "HAS VECTOR USE ELEMENTS " << std::endl;
