<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>SOCI - exchanging data</title>
</head>
<body>
<font size="+3"><span
 style="font-family: helvetica,arial,sans-serif; font-weight: bold; color: rgb(0, 0, 255);">SOCI</span></font><br>
<span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 255); font-weight: bold;">The
C++ Database Access Library</span><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 255);"><br>
<br>
</span>
<h3>Exchanging data</h3>
<a href="#bind_local">Binding local data</a><br>
<div style="margin-left: 40px;"><a href="#bind_output">Binding output
data</a><br>
<a href="#bind_input">Binding input data</a><br>
<a href="#bind_position">Binding by position</a><br>
<a href="#bind_name">Binding by name</a><br>
</div>
<a href="exchange.html#indicators">Indicators</a><br>
<a href="#types">Types</a><br>
<div style="margin-left: 40px;"><a href="#static">Static binding</a><br>
<a href="#static_bulk">Static binding for bulk operations</a><br>
<a href="#dynamic">Dynamic resultset binding</a><br>
<a href="#custom_types">Extending with user-provided datatypes</a><br>
<a href="#object_relational">Object-relational mapping</a><br>
</div>
<a href="#blob">Large objects (BLOBs)</a><br>
<br>
<h4><a name="bind_local"></a>Binding local data</h4>
<b>Note:</b><br>
The Oracle documentation uses two terms: <i>defining</i> (for
instructing the library where the <i>output</i> data should go) and <i>binding</i>
(for the <i>input</i> data and <i>input/output</i> PL/SQL
parameters). For the sake of simplicity, SOCI uses the term <i>binding</i>
for both of these.<br>
<br>
<span style="font-weight: bold;"><a name="bind_output"></a>Binding
output data</span><br>
<br>
The <code>into</code> expression is used to add binding information to
the
statement:<br>
<br>
<table style="width: 100%; background-color: silver; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">
      <pre>int count;<br>sql &lt;&lt; "select count(*) from person", into(count);<br><br>string name;<br>sql &lt;&lt; "select name from person where id = 7", into(name);</pre>
      </td>
    </tr>
  </tbody>
</table>
<br>
In the above examples, some data is retrieved from the database and
transmitted <span style="font-style: italic;">into</span> the given
local variable.<br>
There should be as many <code>into</code> elements as there are
expected columns in the result (see <a href="#dynamic">dynamic
resultset binding</a> for the
exception to this rule).<br>
<br>
<span style="font-weight: bold;"><a name="bind_input"></a>Binding input
data</span><br>
<p>The <code>use</code> expression is used (no pun intended) to
associate the SQL placeholder (written with colon) with the local data:<br>
</p>
<table style="width: 100%; background-color: silver; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">
      <pre>int val = 7;<br>sql &lt;&lt; "insert into numbers(val) values(:val)", use(val);<br></pre>
      </td>
    </tr>
  </tbody>
</table>
<br>
In the above statement, the first "val" is a column name (assuming
that
there is appropriate table <code>numbers</code> with this column), the
second "val" (with colon) is a
placeholder and its name is ignored here, and the third "val" is a name
of local variable.<br>
<p>To better understand the meaning of each "val" above, consider also:<br>
</p>
<table style="width: 100%; background-color: silver; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">
      <pre>int number = 7;<br>sql &lt;&lt; "insert into numbers(val) values(:blabla)", use(number);</pre>
      </td>
    </tr>
  </tbody>
</table>
<br>
Both examples above will insert the value of some local variable into
the table <code>numbers</code> - we say that the local variable is <span
 style="font-style: italic;">used</span> in the SQL statement.<br>
There should be as many <code>use</code> elements as there are
parameters used in the SQL query.<br>
<br>
<span style="font-weight: bold;">Portability note:</span><br>
Older versions of the PostgreSQL client API do not allow to use input
parameters at all. In order to compile SOCI with those old client
libraries, define the <code>SOCI_PGSQL_NOPARAMS</code> preprocessor
name.<br>
<br>
<br>
<span style="font-weight: bold;"><a name="bind_position"></a>Binding by
position</span><br>
<br>
If there is more output or input "holes" in the single statement, it
is possible to use many <code>into</code> and <code>use</code>
expressions, separated by commas, where each expression will be
responsible for the consecutive "hole" in the statement:<br>
<br>
<table style="width: 100%; background-color: silver; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">
      <pre>string firstName = "John", lastName = "Smith";<br>int personId = 7;<br><br>sql &lt;&lt; "insert into person(id, firstname, lastname) values(:id, :fn, :ln)",<br>       use(personId), use(firstName), use(lastName);<br><br>sql &lt;&lt; "select firstname, lastname from person where id = :id",<br>       into(firstName), into(lastName), use(personId);<br></pre>
      </td>
    </tr>
  </tbody>
</table>
<br>
In the code above, the order of "holes" in the SQL statement and the
order of <code>into</code> and <code>use</code> expression should
match. <br>
<br>
<span style="font-weight: bold;"><a name="bind_name"></a>Binding by name</span><br>
<br>
The SQL placeholders that have their names (with colon) can be bound
by name.<br>
<br>
This allows to use different order:<br>
<br>
<table style="width: 100%; background-color: silver; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">
      <pre>string firstName = "John", lastName = "Smith";<br>int personId = 7;<br>sql &lt;&lt; "insert into person(id, firstname, lastname) values(:id, :fn, :ln)",<br>       use(firstName, "fn"), use(lastName, "ln"), use(personId, "id");<br></pre>
      </td>
    </tr>
  </tbody>
</table>
<br>
or bind the same local data to many "holes" at the same time:<br>
<br>
<table style="width: 100%; background-color: silver; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">
      <pre>string addr = "...";<br>sql &lt;&lt; "update person"<br>       " set mainaddress = :addr, contactaddress = :addr"<br>       " where id = 7",<br>       use(addr, "addr);</pre>
      </td>
    </tr>
  </tbody>
</table>
<br>
<span style="font-weight: bold;">Portability notes:</span><br>
The PostgreSQL backend allows to use the "native" PostgreSQL way of
naming parameters in the query, which is by numbers like <code>$1</code>,
<code>$2</code>, <code>$3</code>, etc. In fact, the backend <span
 style="font-style: italic;">rewrites</span>
the given query to the native form. For portability reasons, it is
recommended to use named parameters, as shown in the examples above.<br>
The query rewriting can be switched off by compiling the backend with
the <code>SOCI_PGSQL_NOBINDBYNAME</code> name defined.<br>
<br>
<h4><a name="indicators"></a>Indicators<br>
</h4>
In order to support null values and other conditions which are not
real errors, the concept of <i>indicator</i> is provided.<br>
<p>For example, when the following SQL query is executed:<br>
</p>
<table style="width: 100%; background-color: silver; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">
      <pre>select name from person where id = 7</pre>
      </td>
    </tr>
  </tbody>
</table>
<p>there are three possible outcomes: </p>
<ol>
  <li>there is a person with id = 7 and his name is returned</li>
  <li>there is a person with id = 7, but he has no name (his name is
null)</li>
  <li>there is no such person</li>
</ol>
<p>Whereas the first alternative is easy, the other two are more
complex. Moreover, they are not necessarily errors from the
application's point of view and what's more interesting, they are <i>different</i>
and the application may wish to detect which is the case.<br>
The following example does this:<br>
</p>
<table style="width: 100%; background-color: silver; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">
      <pre>string name;<br>eIndicator ind;<br><br>sql &lt;&lt; "select name from person where id = 7", into(name, ind);<br><br>switch (ind)<br>{<br>case eOK:<br>    // the data was returned without problems<br>    break;<br>case eNoData:<br>    // no such person<br>    break;<br>case eNull:<br>    // there is a person, but he has no name (his name is null)<br>    break;<br>case eTruncated:<br>    // the name was returned only in part,<br>    // because the provided buffer was too short<br>    // (not possible with std::string, but possible with char* and char[])<br>    break;<br>}</pre>
      </td>
    </tr>
  </tbody>
</table>
<p><br>
The use of indicator variable is optional, but if it is not used and
the result would be either <code>eNoData</code> or <code>eNull</code>,
then the exception is thrown. This means that you should use indicator
variables everywhere where the application logic (and database schema)
allow "no such object" or "attribute not set" conditions. </p>
<p>Indicator variables can be also used when binding input data, to
control whether the data is to be used as provided, or explicitly
overrided to be null:<br>
</p>
<table style="width: 100%; background-color: silver; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">
      <pre>int id = 7;<br>string name;<br>eIndicator ind = eNull;<br>sql &lt;&lt; "insert into person(id, name) values(:id, :name)",<br>       use(id), use(name, ind);<br></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>In the above example, the row is inserted with <code>name</code>
attribute set to null. </p>
<p>Indicator variables can also be used in conjunction with vector
based insert, update, and select statements:<br>
</p>
<table style="width: 100%; background-color: silver; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">
      <pre>vector&lt;string&gt; names(100);<br>vector&lt;eIndicator&gt; inds;<br>sql &lt;&lt; "select name from person where id = 7", into(names, inds);<br></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>The above example retrieves first 100 rows of data (or less). The
initial size of <code>names</code> vector provides the (maximum)
number of rows that should be read. Both vectors will be
automatically resized according to the number of rows that were
actually read.<br>
</p>
<p>The following example inserts null for each value of name:<br>
</p>
<table style="width: 100%; background-color: silver; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">
      <pre>vector&lt;int&gt; ids;<br>vector&lt;string&gt; names;<br>vector&lt;eIndicator&gt; nameIndicators;<br><br>for (int i = 0; i != 10; ++i)<br>{<br>    ids.push_back(i);<br>    names.push_back("");<br>    nameIndicators.push_back(eNull);<br>}<br><br>sql &lt;&lt; "insert into person(id, name) values(:id, :name)",<br>       use(ids), use(name, nameIndicators);</pre>
      </td>
    </tr>
  </tbody>
</table>
<br>
<h4><a name="types"></a>Types</h4>
<span style="font-weight: bold;"><a name="static"></a>Static type
binding</span><br>
<br>
The static binding for types is most useful when the types used in
the database are known at compile time - this was already presented
above with the help of <code>into</code> and <code>use</code>
functions.<br>
The following types are currently supported for use with <code>into</code>
and <code>use</code> expressions:
<ul>
  <li><code>char</code> (for character values)</li>
  <li><code>short</code>, <code>int</code>, <code>unsigned
long</code>, <code>double</code> (for numeric values)</li>
  <li><code>char*</code>, <code>char[]</code>, <code>std::string</code>
(for string values)</li>
  <li><code>std::tm</code><code></code> (for datetime
values)</li>
  <li><code>SOCI::Statement</code> (for nested statements and PL/SQL
cursors)</li>
  <li><code>SOCI::BLOB</code> (for Binary Large OBjects)</li>
  <li><code>SOCI::RowID</code> (for row identifiers)</li>
</ul>
<p>See the test code that accompanies the library to see how each of
these types is used.<br>
</p>
<p><span style="font-weight: bold;"><a name="static_bulk"></a>Static
type binding for bulk operations</span><br>
</p>
<p>Bulk inserts, updates, and selects are supported through the
following <code>std::vector</code> based into and use types:
</p>
<ul>
  <li><code>std::vector&lt;char&gt;</code></li>
  <li><code>std::vector&lt;short&gt;</code></li>
  <li><code>std::vector&lt;int&gt;</code></li>
  <li><code>std::vector&lt;unsigned long&gt;</code></li>
  <li><code>std::vector&lt;double&gt;</code></li>
  <li><code>std::vector&lt;std::string&gt;</code></li>
  <li><code>std::vector&lt;std::tm&gt;</code></li>
</ul>
Use of the vector based types mirrors that of the standard types, with
the size of the vector used to specify the number of records to process
at a time. See below for examples.<br>
<br>
<span style="font-weight: bold;"><a name="dynamic"></a>Dynamic
resultset binding</span><br>
<br>
For certain applications it is desirable to be able to select data from
arbitrarily
structured tables (e.g. via "<code>select * </code>") and format the
resulting data based upon its type.
SOCI supports this through the <code>SOCI::Row</code> and <code>SOCI::ColumnProperties</code>
classes.
<p>Data is selected into a <code>Row</code> object, which holds <code>ColumnProperties</code>
objects describing
the type of data contained in each column. Once the data type for each
column is known,
the data can be formatted appropriately.
</p>
<p>
For example, the code below creates an XML document from a selected row
of data from an arbitrary table:<br>
</p>
<table style="width: 100%; background-color: silver; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">
      <pre>Session sql("oracle", "service=db1", "user=scott", "password=tiger");<br>  <br>sql &lt;&lt; "create table ex2(num NUMBER, str VARCHAR2(20), dt DATE)";<br><br>int num_in = 123;<br>std::string str_in("my name");<br>std::time_t dt_in = time(0);<br><br>sql &lt;&lt; "insert into ex2 values(:num1, :str1, :dt1)",<br>    use(num_in), use(str_in), use(dt_in);<br>    <br>Row r;<br>sql &lt;&lt; "select * from ex2", into(r);<br>  <br>std::ostringstream doc;<br>doc &lt;&lt; "&lt;row&gt;" &lt;&lt; std::endl;<br>for(int i=0; i&lt;r.size(); ++i)<br>{<br>    const ColumnProperties&amp; props = r.getProperties(i);<br>    doc &lt;&lt; '&lt;' &lt;&lt; props.getName() &lt;&lt; '&gt;';<br>    switch(props.getDataType())<br>    {<br>    case eString:<br>        doc &lt;&lt; r.get&lt;std::string&gt;(i);<br>        break;<br>    case eDouble:<br>        doc &lt;&lt; r.get&lt;double&gt;(i);<br>        break;<br>    case eInteger:<br>        doc &lt;&lt; r.get&lt;int&gt;(i);<br>        break;<br>    case eUnsignedLong:<br>        doc &lt;&lt; r.get&lt;unsigned long&gt;(i);<br>        break;<br>    case eDate:<br>        std::tm when = r.get&lt;std::tm&gt;(i);<br>        doc &lt;&lt; asctime(&amp;when);<br>        break;<br>    }<br>    doc &lt;&lt; "&lt;/" &lt;&lt; props.getName() &lt;&lt; '&gt;' &lt;&lt; std::endl;  <br>}<br>doc &lt;&lt; "&lt;/row&gt;";</pre>
      </td>
    </tr>
  </tbody>
</table>
<p><br>
The following table shows the type <code>T</code> parameter that
should be passed to
<code>Row::get&lt;T&gt;()</code> for each possible SOCI Data Type that
can be returned from
<code>ColumnProperties::getDataType()</code>. <code>Row::get&lt;T&gt;()</code>
throws an exception of type
<code>std::bad_cast</code> if an incorrect type <code>T</code> is
used.
</p>
<table border="1">
  <tbody>
    <tr>
      <th>Oracle Data Type</th>
      <th>Postgres Data Type</th>
      <th>SOCI Data Type</th>
      <th><code>Row::get&lt;T&gt;</code> specializations</th>
    </tr>
    <tr>
      <td>number<span style="font-style: italic;"> (where scale &gt; 0)</span><br>
      </td>
      <td style="vertical-align: top;">float4, float8, numeric<br>
      </td>
      <td><code>eDouble</code></td>
      <td><code>double</code></td>
    </tr>
    <tr>
      <td>number<span style="font-style: italic;"> <br>
(where scale = 0 and precision &lt;</span> <span
 style="font-style: italic;">std::numeric_limits&lt;int&gt;::digits10)</span>
      </td>
      <td style="vertical-align: top;">bool, int2, int4, int8<br>
      </td>
      <td><code>eInteger</code></td>
      <td><code>int</code></td>
    </tr>
    <tr>
      <td>number<br>
      <span style="font-style: italic;"></span></td>
      <td style="vertical-align: top;">oid<br>
      </td>
      <td><code>eUnsignedLong</code></td>
      <td><code>unsigned long</code></td>
    </tr>
    <tr>
      <td>char, varchar, varchar2<br>
      </td>
      <td style="vertical-align: top;">text, varchar, cstring, char,
bpchar<br>
      </td>
      <td><code>eString</code></td>
      <td><code>std::string</code></td>
    </tr>
    <tr>
      <td>date<br>
      </td>
      <td style="vertical-align: top;">abstime, reltime, data, time,
timestamp, timestamptz, timetz<br>
      </td>
      <td><code>eDate</code></td>
      <td><code>std::tm</code><code></code></td>
    </tr>
  </tbody>
</table>
<br>
<span style="font-weight: bold;"></span><br>
<span style="font-weight: bold;"><a name="custom_types"></a>Extending
SOCI to support custom (user-defined) C++ types</span><br>
<br>
SOCI can be easily extended through user code so that custom types can
be used transparently to insert into, update, and select from the
database.
<p>To do so, provide an appropriate specialization of the <code>TypeConversion</code>
struct
that converts to and from one of the SOCI Base Types listed below:</p>
<table border="1">
  <tbody>
    <tr>
      <th>Oracle Data Type</th>
      <th>SOCI Base Type</th>
    </tr>
    <tr>
      <td>number<br>
      </td>
      <td><code>double</code></td>
    </tr>
    <tr>
      <td>number<br>
      </td>
      <td><code>int</code></td>
    </tr>
    <tr>
      <td>number<br>
      </td>
      <td><code>unsigned long</code></td>
    </tr>
    <tr>
      <td>varchar, varchar2<br>
      </td>
      <td><code>std::string</code></td>
    </tr>
    <tr>
      <td>char<br>
      </td>
      <td><code>char</code></td>
    </tr>
    <tr>
      <td>date<br>
      </td>
      <td><code>std::tm</code></td>
    </tr>
  </tbody>
</table>
<p>There are three required class members for a valid <code>TypeConversion</code>
specialization:
</p>
<ul>
  <li>the <code>base_type</code> trait, defining the base type</li>
  <li>the <code>from()</code> static member function, converting from
the base type</li>
  <li>the <code>to()</code> static member function, converting to the
base type</li>
</ul>
<p>(Note that no database-specific code is required.)</p>
<p>
The following example shows how application code could extend SOCI to
transparently support <code>boost::gregorian::date</code>:<br>
</p>
<table style="width: 100%; background-color: silver; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">
      <pre>#include "boost/date_time/gregorian/gregorian.hpp"<br><br>template&lt;&gt;<br>struct TypeConversion&lt;boost::gregorian::date&gt;<br>{<br>    typedef std::tm base_type;<br>    static boost::gregorian::date from(std::tm&amp; t)<br>    {<br>        boost::gregorian::months_of_year month = <br>            static_cast&lt;boost::gregorian::months_of_year&gt;(t.tm_mon + 1);<br>        <br>        boost::gregorian::date d(t.tm_year + 1900, month, t.tm_mday);<br>        return d;<br>    }<br>    static std::tm to(boost::gregorian::date&amp; d)<br>    {<br>        std::tm t;<br>        <br>        t.tm_isdst = -1;<br>        t.tm_year = d.year() - 1900;<br>        t.tm_mon = d.month() - 1;<br>        t.tm_mday = d.day();<br>        t.tm_hour = 0;<br>        t.tm_min = 0;<br>        t.tm_sec = 0;<br>        std::mktime(&amp;t); //normalize and compute remaining fields<br>          <br>        return t;<br>    }<br>};<br></pre>
      </td>
    </tr>
  </tbody>
</table>
<p><br>
With the above <code>TypeConversion</code> specialization in place, it
is possible to
use <code>boost::gregorian::date</code> directly with SOCI, binding
input or output, either statically or via a dynamic resultset:<br>
</p>
<table style="width: 100%; background-color: silver; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">
      <pre>using boost::gregorian::date;<br>    <br>Session sql("oracle", "service=db1", "user=scott", "password=tiger");<br><br>sql &lt;&lt; "create table test_boost(when DATE)";<br>date dIn(1999, boost::gregorian::Feb, 1);<br>sql &lt;&lt; "insert into test_boost values(:when)", use(dIn);<br>    <br>date dOut(boost::gregorian::not_a_date_time);<br>sql &lt;&lt; "select when from test_boost", into(dOut);<br>assert(dIn == dOut);<br><br>Row r;<br>sql &lt;&lt; "select * from test_boost", into(r);<br>assert(r.get&lt;date&gt;(0) == dIn);<br><br>std::vector&lt;date&gt; datesIn;<br>for (int i = 2; i != 12; ++i)<br>{<br>    date d(1999, boost::gregorian::Feb, i);<br>    datesIn.push_back(d);<br>}<br>sql &lt;&lt; "insert into test_boost values(:when)", use(datesIn);<br><br>std::vector&lt;date&gt; datesOut(10);<br>sql &lt;&lt; "select when from test_boost where when &gt; :d", use(dIn), into(datesOut);<br>assert(datesIn == datesOut);<br></pre>
      </td>
    </tr>
  </tbody>
</table>
<p><br>
The other possibility to extend SOCI with custom data types is to use
the <code>IntoType&lt;T&gt;</code>
and <code>UseType&lt;T&gt;</code>
class templates, which specializations can be user-provided. These
specializations need to implement the interface defined by,
respectively, the <code>IntoTypeBase</code> and <code>UseTypeBase</code>
classes.<br>
</p>
<p>Note that when specializing these template classes for handling your
own types, you are free to choose the expected parameters for the
classes' constructors. The template functions <code>into</code> and <code>use</code>
support up to 5 parameters, which are just forwarded to the constructor
of appropriate class. The only convention is that when the indicator
variable is used (see below), it should appear in the second position.
Please refer to the library source code to see how this is done for the
standard types.<br>
</p>
<h4><a name="object_relational"></a>Object-relational mapping</h4>
SOCI provides a class called <code>Values</code> specifically to
enable
object-relational mapping via <code>TypeConversion</code>
specializations.<br>
<br>
For example, the following code maps a <code>Person</code> object to
and from a
database table containing columns "ID", "FIRST_NAME", "LAST_NAME", and
"GENDER".&nbsp; <br>
<br>
Note that the mapping is non-invasive - the <code>Person </code>object
itself doesn't contain any SOCI-specific code:<br>
<br>
<table style="width: 100%; background-color: silver; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">
      <pre>struct Person<br>{<br>    int id;<br>    std::string firstName;<br>    std::string lastName;<br>    std::string gender;<br>};<br><br>template&lt;&gt; struct TypeConversion&lt;Person&gt;<br>{<br>    typedef Values base_type;<br>    static Person from(Values const &amp;v)<br>    {<br>        Person p;<br>        p.id = v.get&lt;int&gt;("ID");<br>        p.firstName = v.get&lt;std::string&gt;("FIRST_NAME");<br>        p.lastName = v.get&lt;std::string&gt;("LAST_NAME");<br><br>        // p.gender will be set to the default value "unknown"<br>        // when the column is null:<br>        p.gender = v.get&lt;std::string&gt;("GENDER", "unknown");<br><br>        // alternatively, the indicator can be tested directly:<br>        // if (v.indicator("GENDER") == eNull)<br>        // {<br>        //     p.gender = "unknown";<br>        // }<br>        // else<br>        // {<br>        //     p.gender = v.get&lt;std::string&gt;("GENDER");<br>        // }<br><br>        return p;<br>    }<br>    static Values to(Person &amp;p)<br>    {<br>        Values v;<br>        v.set("ID", p.id);<br>        v.set("FIRST_NAME", p.firstName);<br>        v.set("LAST_NAME", p.lastName);<br>	v.set("GENDER", p.gender, p.gender.empty() ? eNull : eOK);<br>        return v;<br>    }<br>};<br></pre>
      </td>
    </tr>
  </tbody>
</table>
<br>
With the above <code>TypeConversion</code> specialization in place, it
is possible to use <code>Person</code> directly with SOCI:<br>
<br>
<table style="width: 100%; background-color: silver; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">
      <pre>Session sql("oracle", "service=db1", "user=scott", "password=tiger");<br><br>Person p;<br>p.id = 1;<br>p.lastName = "Smith";<br>p.firstName = "Pat";<br>sql &lt;&lt; "insert into person(id, first_name, last_name) "<br>       "values(:ID, :FIRST_NAME, :LAST_NAME)", use(p);<br><br>Person p1;<br>sql &lt;&lt; "select * from person", into(p1);<br>assert(p1.id == 1);<br>assert(p1.firstName + p.lastName == "PatSmith");<br>assert(p1.gender == "unknown");<br><br>p.firstName = "Patricia";<br>sql &lt;&lt; "update person set first_name = :FIRST_NAME "<br>       "where id = :ID", use(p);<br></pre>
      </td>
    </tr>
  </tbody>
</table>
<p><span style="font-weight: bold;">Note:</span> the <code>Values</code>
class is currently not suited for use outside of <code>TypeConversion</code>
specializations.&nbsp; It is specially designed to facilitate
object-relational mapping when used as shown above.<br>
</p>
<h4><a name="blob"></a>Large objects (BLOBs)<br>
</h4>
<p>The SOCI library provides also an interface for basic operations on
large
objects (BLOBs - Binary Large OBjects).</p>
<table style="width: 100%; background-color: silver; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">
      <pre>BLOB b(sql); // sql is a Session object<br>sql &lt;&lt; "select mp3 from mymusic where id = 123", into(b);</pre>
      </td>
    </tr>
  </tbody>
</table>
<p>The following functions are provided in the <code>BLOB</code>
interface, mimicking the file-like operations:<br>
</p>
<ul>
  <li><code>std::size_t getLen();</code></li>
  <li><code>std::size_t read(std::size_t offset, char *buf, std::size_t
toRead);</code></li>
  <li><code>std::size_t write(std::size_t offset, char const *buf,
std::size_t toWrite);</code></li>
  <li><code>std::size_t append(char const *buf, std::size_t toWrite);</code></li>
  <li><code>void trim(std::size_t newLen);</code></li>
</ul>
The <code>offset</code> parameter is always counted from the beginning
of the BLOB's data.<br>
<br>
<span style="font-weight: bold;">Portability notes:</span><br>
<ol>
  <li>The way to define BLOB table columns and create or destroy BLOB
objects in the database varies between different database engines.
Please see the SQL documentation relevant for the given server to learn
how this is actually done. The test programs provided with the SOCI
library can be also a simple source of full working examples.</li>
  <li>The <code>trim</code> function is not currently available for
the PostgreSQL backend.<br>
  </li>
</ol>
<br>
<table style="width: 100%; text-align: left;" border="0" cellpadding="2"
 cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"><a href="basics.html">Previous
(Connections and simple queries)</a><br>
      </td>
      <td style="vertical-align: top; text-align: right;"><a
 href="statements.html">Next (Statements, procedures and transactions)</a><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<hr style="width: 100%; height: 2px;">Copyright &copy; 2004-2006 Maciej
Sobczak, Stephen Hutton<br>
<br>
</body>
</html>
