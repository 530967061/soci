<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"  http-equiv="content-type" />
  <link rel="stylesheet" type="text/css" href="style.css" />
  <title>SOCI - structure</title>
</head>

<body>
<p class="banner">SOCI - The C++ Database Access Library</p>

<h2>Library structure, files and compilation</h2>

<div class="navigation">
<a href="#structure">Structure</a><br />
<a href="#compilation">Compilation</a><br />
</div>

<h3 id="structure">The SOCI library structure</h3>

<div class="diagram">
<img alt="Library structure diagram" src="structure.png" />
</div>

<p>The core part of the library and the backend interface definition are
placed in the <code>core</code> directory of the library distribution.
The <code>soci-backend.h</code> file is an internal abstract
interface to the actual backends, which are needed to perform
operations on the given database server. Normally, the C++ client
program needs to interface with the <code>soci.h</code> header and the
header(s) relevant to the given backend(s) (for example, <code>soci-oracle.h</code>).
It is possible for the same program to use many backends at the same
time.</p>

<p>The gray boxes above indicate that the SOCI library is extensible and
that there are two aspects of this extensibility: more backends can be
added, and more interfaces (possibly for other languages) can be
defined to reuse the already existing backends.</p>

<p>Everything in SOCI is
declared in the namespace <code>SOCI</code>.
All code examples presented in this documentation assume that your code
begins with something
like:</p>
<pre class="example">
#include "soci.h"
// other includes

using namespace SOCI;

// ...
</pre>

<div class="note">
<p><span class="note">Note:</span>
In simple programs, <code>#include</code> for the relevant
backend is needed only in the file where the <code>Session</code>
object is created, because it is where the name of the backend factory
is referenced. The example program on the <a href="index.html">previous
page</a> shows the appropriate <code>#include</code> directive for the
Oracle backend.</p>
</div>

<h3 id="compilation">Compilation</h3>

<h4>With autotools on Unix/Linux</h4>

<p>Download SOCI distribution: soci-X.Y.Z.tar.gz|tar.bz2|zip, where X.Y.Z is release number.</p>

<p>Unpack sources:
<pre class="example">
$ tar -zxf soci-X.Y.Z.tar.gz
</pre></p>

<p>Configure:
<pre class="example">
$ ./configure
</pre></p>

<p>You may want to pass custom options to <code>./configure</code> script.
Backends can be enabled using options named as <code>--enable-backend-&lt;name&gt;</code> and
disabled using <code>--disable-backend-&lt;name&gt;</code>. There are also <code>--with-&lt;package&gt;</code>
options which can be used to tell the script where required headers and libraries can be found.</p>

<p>Please, run <code>./configure --help</code> to learn what options are available.</p>

<p>Build:
<pre class="example">
$ make
</pre></p>

<p>Install:
<pre class="example">
$ make install
</pre></p>

<p>After the last step, SOCI components should be placed under default installation prefix <code>/usr/local</code> or custom locatoin, if specified using <code>--prefix</code> option.</p>

<h4>With classic Makefiles on Unix/Linux</h4>

<p>Compilation of the client program requires that the SOCI header files
are all visible and accessible to the compiler. Moreover, the library
itself (the core part and the relevant backend part) needs to be
already compiled and linked into
the final executable. For this, the native libraries provided by each
database server should be visible to the compiler and linker as well -
the
actual steps that need to be taken depend on the compiler being used.</p>

<p>The <code>core</code> directory of the library distribution contains
the <code>Makefile.basic</code> that can be used to compile the core part of
the library. Run <code>make -f Makefile.basic</code> or <code>make -f Makefile.basic shared</code> to get
the static and shared versions. Similarly, the <code>backends/<i>name</i></code> directory contains the
backend part for each supported backend with the appropriate <code>Makefile.basic</code>
and the <code>backends/<i>name</i>/test</code>
directory contains the test program for the given backend.</p>

<p>For example, the simplest way to compile the static version of the
library and the test program for PostgreSQL is:</p>

<pre class="example">
$ cd src/core
$ make -f Makefile.basic
$ cd ../backends/postgresql
$ make -f Makefile.basic
$ cd test
$ make -f Makefile.basic
</pre>

<div class="note">
<p><span class="note">Note:</span>
For each backend and its test program, the <code>Makefile.basic</code>s
contain the variables that can have values specific to the given
environment. These variables are placed at the beginning of the <code>Makefile.basic</code>s.
Please review their values in case of any compilation problems.</p>
</div>

<p>The Makefiles for test programs can be a good starting point to find
out correct compiler and linker options.</p>

<h4>With MSVC++ on Windows</h4>

<p>TODO ...</p>

<table class="foot-links" border="0" cellpadding="2" cellspacing="2">
  <tr>
    <td class="foot-link-left">
      <a href="index.html">Previous (Contents)</a>
    </td>
    <td class="foot-link-right">
      <a href="errors.html">Next (Errors)</a>
    </td>
  </tr>
</table>

<p class="copyright">Copyright &copy; 2004-2006 Maciej Sobczak, Stephen Hutton</p>
</body>
</html>
