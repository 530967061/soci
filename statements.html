<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>SOCI - statements, procedures and transactions</title>
</head>
<body>
<font size="+3"><span
 style="font-family: helvetica,arial,sans-serif; font-weight: bold; color: rgb(0, 0, 255);">SOCI</span></font><br>
<span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 255); font-weight: bold;">Simple
Oracle Call Interface</span><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 255);">
(and more)<br>
<br>
</span>
<h3>Statements, procedures and transactions</h3>
<a href="#preparation">Statement preparation and repeated execution</a><br>
<a href="#procedures">Stored procedures</a><br>
<a href="#transactions">Transactions</a><br>
<br>
<br>
<a name="preparation"></a><span style="font-weight: bold;">Statement
preparation and repeated execution</span><br>
<br>
Consider the following examples:<br>
<br>
<table style="width: 100%; background-color: silver; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">
      <pre>// Example 1.<br>for (int i = 0; i != 100; ++i)<br>{<br>    sql &lt;&lt; "insert into numbers(value) values(" &lt;&lt; i &lt;&lt; ")";<br>}<br><br>// Example 2.<br>for (int i = 0; i != 100; ++i)<br>{<br>    sql &lt;&lt; "insert into numbers(value) values(:val)", use(i);<br>}<br></pre>
      </td>
    </tr>
  </tbody>
</table>
<br>
Both examples will populate the table <code>numbers</code> with the
values from <code>0</code> to <code>99</code>.<br>
<p>The
problem is that in both examples, not only the statement execution is
repeated 100 times, but also the statement parsing and preparation.
This means unnecessary overhead, even if some of the database servers
are likely to optimize the second case.<br>
The following example uses the class <code>Statement</code>
explicitly, by preparing the statement only once and repeating its
execution with changing data (note the use of <code>prepare</code>
member of <code>Session</code> class):<br>
</p>
<table style="width: 100%; background-color: silver; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">
      <pre>int i;<br>Statement st = (sql.prepare &lt;&lt;<br>                "insert into numbers(value) values(:val)",<br>                use(i));<br>for (i = 0; i != 100; ++i)<br>{<br>    st.execute(true);<br>}<br></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>The <code>true</code> parameter given to the <code>execute</code>
method indicates that the actual data exchange is wanted, so that the
meaning of the whole example is "prepare the statement and exchange the
data for each value of variable <code>i</code>". </p>
<p>Further performance improvements may be possible by having the
underlying database API group operations together to reduce network
roundtrips. SOCI makes such bulk operations possible by supporting <code>std::vector</code>
based types:<br>
</p>
<table style="width: 100%; background-color: silver; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">
      <pre>// Example 3.<br>const int BATCH_SIZE = 25;<br>std::vector&lt;int&gt; valsIn;<br>for (int i = 0; i != BATCH_SIZE; ++i)<br>{<br>    ids.push_back(i);<br>}<br><br>Statement st = (sql.prepare &lt;&lt; <br>                "insert into numbers(value) values(:val)", <br>                use(valsIn));<br>for (int i = 0; i != 4; ++i)<br>{<br>    st.execute(true);<br>}<br></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>(Of course, the size of the vector that will achieve optimum
performance will vary, depending on many environmental factors, such as
network speed.)
</p>
<p>It is also possible to read all the numbers written in the above
examples:<br>
</p>
<table style="width: 100%; background-color: silver; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">
      <pre>int i;<br>Statement st = (sql.prepare &lt;&lt;<br>                "select value from numbers order by value",<br>                into(i));<br>st.execute();<br>while (st.fetch())<br>{<br>    cout &lt;&lt; i &lt;&lt; '\n';<br>}<br></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>In the above example, the <code>execute</code> method is called
with the default parameter <code>false</code>. This means that the
statement should be executed, but the actual data exchange will be
executed later.<br>
Further <code>fetch</code>
calls perform the actual data retrieval and cursor traversal. The
end-of-cursor condition is indicated by the <code>fetch</code>
function returning <code>false</code>.<br>
</p>
<p>Note: The above code example should be treated as an idiomatic way
of reading many rows of data, <span style="font-style: italic;">one at
a time</span>.<br>
</p>
<p>It is further possible to select records in batches into <code>std::vector</code>
based types, with the size of the vector specifying the number of
records to retrieve in each round trip:<br>
</p>
<table style="width: 100%; background-color: silver; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">
      <pre>std::vector&lt;int&gt; valsOut(100);<br>sql &lt;&lt; "select val from numbers", into(valsOut);<br></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>Above, the value <code>100</code> indicates that no more values
should be retrieved, even if it would be otherwise possible. If there
is less rows than asked for, the vector will be appropriately
down-sized.<br>
</p>
<p>The <code>Statement::execute()</code> and <code>Statement::fetch()</code>
functions can also be used to repeatedly select all rows returned by a
query into a vector based type:<br>
</p>
<table style="width: 100%; background-color: silver; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">
      <pre>const int BATCH_SIZE = 30;<br>std::vector&lt;int&gt; valsOut(BATCH_SIZE);<br>Statement st = (sql.prepare &lt;&lt; <br>                "select value from numbers", <br>                into(valsOut));<br>st.execute();<br>while (st.fetch())<br>{<br>    std::vector&lt;int&gt;::iterator pos;<br>    for(; pos != valsOut.end(); ++pos)<br>    {<br>        cout &lt;&lt; *pos &lt;&lt; '\n'; <br>    }<br><br>    valsOut.resize(BATCH_SIZE);<br>}<br></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>Assuming there are 100 rows returned by the query, the above code
will retrieve and print all of them. Since the output vector was
created with size 30, it will take (at least) 4 calls to <code>fetch()</code>
to retrieve all 100 values. Each call to <code>fetch()</code>
can potentially resize the vector to a size less than its initial size
- how often this happens depends on the underlying database
implementation.
This explains why the <code>resize(BATCH_SIZE)</code> operation is
needed - it is there to ensure that each time the <code>fetch()</code>
is called, the vector is ready to accept the next bunch of values.
Without this operation, the vector <span style="font-style: italic;">might</span>
be getting smaller with subsequent iterations of the loop, forcing more
iterations to be performed (because <span style="font-style: italic;">all</span>
rows will be read anyway), than really needed.<br>
</p>
<p>Notes:<br>
</p>
<ul>
  <li>After performing <code>fetch()</code>, the vector's size might
be <span style="font-style: italic;">less</span> than requested, but <code>fetch()</code>
returning true means that there was <span style="font-style: italic;">at
least one</span> row retrieved.</li>
  <li>It is forbidden to manually resize the vector to the size <span
 style="font-style: italic;">higher</span> than it was initially (this
can cause the vector to reallocate its internal buffer and the library
can lose track of it).</li>
</ul>
Taking these points under consideration, the above code example should
be treated as an idiomatic way of reading many rows by bunches of
requested size.<br>
<br>
<span style="font-weight: bold;">Portability note:</span><br>
Actually, Oracle and PostgreSQL backends guarantee that the requested
number of rows will be read with each fetch and that the vector will
never be down-sized (unless the end of rowset condition is met, of
course). This means that for these two servers, the manual vector
resizing is not needed - the vector will keep its size until the end of
rowset. The above idiom, however, is provided with future backends in
mind, where the constant size of the vector might be too expensive to
guarantee and where allowing <code>fetch</code> to down-size the
vector even before reaching the end of rowset might buy some
performance gains.<br>
<br>
<span style="font-weight: bold;"><a name="procedures"></a>Stored
procedures</span><br>
<br>
The <code>Procedure</code> class provides a convenient mechanism for
calling stored procedures:<br>
<br>
<table style="width: 100%; background-color: silver; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">
      <pre>sql &lt;&lt; "create or replace procedure echo(output out varchar2,"<br>       "input in varchar2) as "<br>       "begin output := input; end;";<br><br>std::string in("my message");<br>std::string out;<br>Procedure proc = (sql.prepare &lt;&lt; "echo(:output, :input)", <br>                                  use(out, "output"),<br>                                  use(in, "input"));<br>proc.execute(true);<br>assert(out == "my message");</pre>
      </td>
    </tr>
  </tbody>
</table>
<br>
<span style="font-weight: bold;">Portability note:</span><br>
The above way of calling stored procedures is provided for portability
of the code that might need it. It is of course still possible to call
procedures or functions using the syntax supported by the given
database server.<br>
<br>
<span style="font-weight: bold;"><a name="transactions"></a>Transactions</span><br>
<br>
The SOCI library provides the following members of the <code>Session</code>
class for transaction management:<br>
<ul>
  <li><code>void begin();</code></li>
  <li><code>void commit();</code></li>
  <li><code>void rollback();</code></li>
</ul>
<span style="font-weight: bold;">Portability note:</span><br>
Different database servers have different policies with regard to the
implicit transaction management. Some of them start the implicit
transaction with the first DML statement and keep it open until
explicitly commited or rolled back (or closing the whole session).
Others will treat each statement as if it was a separate, auto-commited
transaction. For better compatibility, it is recommended to use the
above functions for explicit transaction management.<br>
<br>
<table style="width: 100%; text-align: left;" border="0" cellpadding="2"
 cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"><a href="exchange.html">Previous
(Exchanging data)</a><br>
      </td>
      <td style="vertical-align: top; text-align: right;"><a
 href="beyond.html">Next (Beyond SOCI)</a><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<hr style="width: 100%; height: 2px;">Copyright &copy; 2004-2005 Maciej
Sobczak, Steve Hutton<br>
<br>
</body>
</html>
